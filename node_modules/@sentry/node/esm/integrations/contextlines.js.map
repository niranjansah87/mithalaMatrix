{"version":3,"file":"contextlines.js","sourceRoot":"","sources":["../../src/integrations/contextlines.ts"],"names":[],"mappings":"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","sourcesContent":["import { getCurrentHub } from '@sentry/core';\nimport { Event, EventProcessor, Integration } from '@sentry/types';\nimport { addContextToFrame } from '@sentry/utils';\nimport { readFile } from 'fs';\nimport { LRUMap } from 'lru_map';\n\nimport { NodeClient } from '../client';\n\nconst FILE_CONTENT_CACHE = new LRUMap<string, string | null>(100);\nconst DEFAULT_LINES_OF_CONTEXT = 7;\n\n// TODO: Replace with promisify when minimum supported node >= v8\nfunction readTextFileAsync(path: string): Promise<string> {\n  return new Promise((resolve, reject) => {\n    readFile(path, 'utf8', (err, data) => {\n      if (err) reject(err);\n      else resolve(data);\n    });\n  });\n}\n\n/**\n * Resets the file cache. Exists for testing purposes.\n * @hidden\n */\nexport function resetFileContentCache(): void {\n  FILE_CONTENT_CACHE.clear();\n}\n\ninterface ContextLinesOptions {\n  /**\n   * Sets the number of context lines for each frame when loading a file.\n   * Defaults to 7.\n   *\n   * Set to 0 to disable loading and inclusion of source files.\n   **/\n  frameContextLines?: number;\n}\n\n/** Add node modules / packages to the event */\nexport class ContextLines implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'ContextLines';\n\n  /**\n   * @inheritDoc\n   */\n  public name: string = ContextLines.id;\n\n  public constructor(private readonly _options: ContextLinesOptions = {}) {}\n\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(addGlobalEventProcessor: (callback: EventProcessor) => void): void {\n    // This is only here to copy frameContextLines from init options if it hasn't\n    // been set via this integrations constructor.\n    //\n    // TODO: Remove on next major!\n    if (this._options.frameContextLines === undefined) {\n      const initOptions = getCurrentHub().getClient<NodeClient>()?.getOptions();\n      // eslint-disable-next-line deprecation/deprecation\n      this._options.frameContextLines = initOptions?.frameContextLines;\n    }\n\n    const contextLines =\n      this._options.frameContextLines !== undefined ? this._options.frameContextLines : DEFAULT_LINES_OF_CONTEXT;\n\n    addGlobalEventProcessor(event => this.addSourceContext(event, contextLines));\n  }\n\n  /** Processes an event and adds context lines */\n  public async addSourceContext(event: Event, contextLines: number): Promise<Event> {\n    const frames = event.exception?.values?.[0].stacktrace?.frames;\n\n    if (frames && contextLines > 0) {\n      const filenames: Set<string> = new Set();\n\n      for (const frame of frames) {\n        if (frame.filename) {\n          filenames.add(frame.filename);\n        }\n      }\n\n      const sourceFiles = await readSourceFiles(filenames);\n\n      for (const frame of frames) {\n        if (frame.filename && sourceFiles[frame.filename]) {\n          try {\n            const lines = (sourceFiles[frame.filename] as string).split('\\n');\n            addContextToFrame(lines, frame, contextLines);\n          } catch (e) {\n            // anomaly, being defensive in case\n            // unlikely to ever happen in practice but can definitely happen in theory\n          }\n        }\n      }\n    }\n\n    return event;\n  }\n}\n\n/**\n * This function reads file contents and caches them in a global LRU cache.\n *\n * @param filenames Array of filepaths to read content from.\n */\nasync function readSourceFiles(filenames: Set<string>): Promise<Record<string, string | null>> {\n  const sourceFiles: Record<string, string | null> = {};\n\n  for (const filename of filenames) {\n    const cachedFile = FILE_CONTENT_CACHE.get(filename);\n    // We have a cache hit\n    if (cachedFile !== undefined) {\n      // If stored value is null, it means that we already tried, but couldn't read the content of the file. Skip.\n      if (cachedFile === null) {\n        continue;\n      }\n\n      // Otherwise content is there, so reuse cached value.\n      sourceFiles[filename] = cachedFile;\n      continue;\n    }\n\n    let content: string | null = null;\n    try {\n      content = await readTextFileAsync(filename);\n    } catch (_) {\n      //\n    }\n\n    FILE_CONTENT_CACHE.set(filename, content);\n    sourceFiles[filename] = content;\n  }\n\n  return sourceFiles;\n}\n"]}