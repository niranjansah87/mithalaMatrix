{"version":3,"file":"userIntegrations.js","sourceRoot":"","sources":["../../src/utils/userIntegrations.ts"],"names":[],"mappings":";;AAcA;;;;;;;;GAQG;AACH,8DAA8D;AAC9D,SAAS,YAAY,CAAC,GAAwB,EAAE,OAAe,EAAE,KAAc;IAC7E,iDAAiD;IACjD,IAAM,KAAK,GAAG,OAAO,CAAC,KAAK,CAAC,iBAAiB,CAAC,CAAC;IAC/C,IAAI,KAAK,KAAK,IAAI,EAAE;QAClB,GAAG,CAAC,OAAO,CAAC,GAAG,KAAK,CAAC;KACtB;SAAM;QACL,YAAY,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC;KAC9C;AACH,CAAC;AAED;;;;;;;;;;;GAWG;AACH,SAAgB,cAAc,CAC5B,WAAwB,EACxB,gBAAkC,EAClC,OAAqB;IAArB,wBAAA,EAAA,YAAqB;IAErB,IAAI,KAAK,CAAC,OAAO,CAAC,gBAAgB,CAAC,EAAE;QACnC,OAAO,qBAAqB,CAAC,WAAW,EAAE,gBAAgB,EAAE,OAAO,CAAC,CAAC;KACtE;SAAM;QACL,OAAO,wBAAwB,CAAC,WAAW,EAAE,gBAAgB,EAAE,OAAO,CAAC,CAAC;KACzE;AACH,CAAC;AAVD,wCAUC;AAED,SAAS,qBAAqB,CAC5B,WAAwB,EACxB,gBAA+B,EAC/B,OAAgB;IAEhB,IAAI,YAAY,GAAG,KAAK,CAAC;IACzB,4DAA4D;IAC5D,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,gBAAgB,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;QAChD,IAAI,gBAAgB,CAAC,CAAC,CAAC,CAAC,IAAI,KAAK,WAAW,CAAC,IAAI,EAAE;YACjD,YAAY,GAAG,IAAI,CAAC;SACrB;QAED,IAAM,EAAE,GAAG,OAAO,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;QAC7C,IAAI,EAAE,EAAE;YACN,YAAY,CAAC,gBAAgB,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,OAAO,EAAE,EAAE,CAAC,KAAK,CAAC,CAAC;SACzD;KACF;IAED,IAAI,YAAY,EAAE;QAChB,OAAO,gBAAgB,CAAC;KACzB;IACD,wBAAW,gBAAgB,GAAE,WAAW,GAAE;AAC5C,CAAC;AAED,SAAS,wBAAwB,CAC/B,WAAwB,EACxB,oBAA8C,EAC9C,OAAgB;IAEhB,IAAM,OAAO,GAA6B,UAAA,mBAAmB;QAC3D,IAAM,qBAAqB,GAAG,oBAAoB,CAAC,mBAAmB,CAAC,CAAC;QACxE,OAAO,qBAAqB,CAAC,WAAW,EAAE,qBAAqB,EAAE,OAAO,CAAC,CAAC;IAC5E,CAAC,CAAC;IACF,OAAO,OAAO,CAAC;AACjB,CAAC","sourcesContent":["import { Integration } from '@sentry/types';\n\nexport type UserFunctionIntegrations = (integrations: Integration[]) => Integration[];\nexport type UserIntegrations = Integration[] | UserFunctionIntegrations;\n\ntype Options = {\n  [integrationName: string]:\n    | {\n        keyPath: string;\n        value: unknown;\n      }\n    | undefined;\n};\n\n/**\n * Recursively traverses an object to update an existing nested key.\n * Note: The provided key path must include existing properties,\n * the function will not create objects while traversing.\n *\n * @param obj An object to update\n * @param value The value to update the nested key with\n * @param keyPath The path to the key to update ex. fizz.buzz.foo\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction setNestedKey(obj: Record<string, any>, keyPath: string, value: unknown): void {\n  // Ex. foo.bar.zoop will extract foo and bar.zoop\n  const match = keyPath.match(/([a-z]+)\\.(.*)/i);\n  if (match === null) {\n    obj[keyPath] = value;\n  } else {\n    setNestedKey(obj[match[1]], match[2], value);\n  }\n}\n\n/**\n * Retrieves the patched integrations with the provided integration.\n *\n * The integration must be present in the final user integrations, and they are compared\n * by integration name. If the user has defined one, there's nothing to patch; if not,\n * the provided integration is added.\n *\n * @param integration The integration to patch, if necessary.\n * @param userIntegrations Integrations defined by the user.\n * @param options options to update for a particular integration\n * @returns Final integrations, patched if necessary.\n */\nexport function addIntegration(\n  integration: Integration,\n  userIntegrations: UserIntegrations,\n  options: Options = {},\n): UserIntegrations {\n  if (Array.isArray(userIntegrations)) {\n    return addIntegrationToArray(integration, userIntegrations, options);\n  } else {\n    return addIntegrationToFunction(integration, userIntegrations, options);\n  }\n}\n\nfunction addIntegrationToArray(\n  integration: Integration,\n  userIntegrations: Integration[],\n  options: Options,\n): Integration[] {\n  let includesName = false;\n  // eslint-disable-next-line @typescript-eslint/prefer-for-of\n  for (let x = 0; x < userIntegrations.length; x++) {\n    if (userIntegrations[x].name === integration.name) {\n      includesName = true;\n    }\n\n    const op = options[userIntegrations[x].name];\n    if (op) {\n      setNestedKey(userIntegrations[x], op.keyPath, op.value);\n    }\n  }\n\n  if (includesName) {\n    return userIntegrations;\n  }\n  return [...userIntegrations, integration];\n}\n\nfunction addIntegrationToFunction(\n  integration: Integration,\n  userIntegrationsFunc: UserFunctionIntegrations,\n  options: Options,\n): UserFunctionIntegrations {\n  const wrapper: UserFunctionIntegrations = defaultIntegrations => {\n    const userFinalIntegrations = userIntegrationsFunc(defaultIntegrations);\n    return addIntegrationToArray(integration, userFinalIntegrations, options);\n  };\n  return wrapper;\n}\n"]}