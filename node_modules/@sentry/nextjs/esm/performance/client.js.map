{"version":3,"file":"client.js","sourceRoot":"","sources":["../../src/performance/client.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport { Primitive, Transaction, TransactionContext } from '@sentry/types';\nimport { fill, getGlobalObject, stripUrlQueryAndFragment } from '@sentry/utils';\nimport { default as Router } from 'next/router';\n\nconst global = getGlobalObject<Window>();\n\ntype StartTransactionCb = (context: TransactionContext) => Transaction | undefined;\n\nconst DEFAULT_TAGS = {\n  'routing.instrumentation': 'next-router',\n} as const;\n\nlet activeTransaction: Transaction | undefined = undefined;\nlet prevTransactionName: string | undefined = undefined;\nlet startTransaction: StartTransactionCb | undefined = undefined;\n\n/**\n * Creates routing instrumention for Next Router. Only supported for\n * client side routing. Works for Next >= 10.\n *\n * Leverages the SingletonRouter from the `next/router` to\n * generate pageload/navigation transactions and parameterize\n * transaction names.\n */\nexport function nextRouterInstrumentation(\n  startTransactionCb: StartTransactionCb,\n  startTransactionOnPageLoad: boolean = true,\n  startTransactionOnLocationChange: boolean = true,\n): void {\n  startTransaction = startTransactionCb;\n  Router.ready(() => {\n    // We can only start the pageload transaction when we have access to the parameterized\n    // route name. Setting the transaction name after the transaction is started could lead\n    // to possible race conditions with the router, so this approach was taken.\n    if (startTransactionOnPageLoad) {\n      prevTransactionName = Router.route !== null ? stripUrlQueryAndFragment(Router.route) : global.location.pathname;\n      activeTransaction = startTransactionCb({\n        name: prevTransactionName,\n        op: 'pageload',\n        tags: DEFAULT_TAGS,\n      });\n    }\n\n    // Spans that aren't attached to any transaction are lost; so if transactions aren't\n    // created (besides potentially the onpageload transaction), no need to wrap the router.\n    if (!startTransactionOnLocationChange) return;\n\n    // `withRouter` uses `useRouter` underneath:\n    // https://github.com/vercel/next.js/blob/de42719619ae69fbd88e445100f15701f6e1e100/packages/next/client/with-router.tsx#L21\n    // Router events also use the router:\n    // https://github.com/vercel/next.js/blob/de42719619ae69fbd88e445100f15701f6e1e100/packages/next/client/router.ts#L92\n    // `Router.changeState` handles the router state changes, so it may be enough to only wrap it\n    // (instead of wrapping all of the Router's functions).\n    const routerPrototype = Object.getPrototypeOf(Router.router);\n    fill(routerPrototype, 'changeState', changeStateWrapper);\n  });\n}\n\ntype RouterChangeState = (\n  method: string,\n  url: string,\n  as: string,\n  options: Record<string, any>,\n  ...args: any[]\n) => void;\ntype WrappedRouterChangeState = RouterChangeState;\n\n/**\n * Wraps Router.changeState()\n * https://github.com/vercel/next.js/blob/da97a18dafc7799e63aa7985adc95f213c2bf5f3/packages/next/next-server/lib/router/router.ts#L1204\n * Start a navigation transaction every time the router changes state.\n */\nfunction changeStateWrapper(originalChangeStateWrapper: RouterChangeState): WrappedRouterChangeState {\n  const wrapper = function (\n    this: any,\n    method: string,\n    // The parameterized url, ex. posts/[id]/[comment]\n    url: string,\n    // The actual url, ex. posts/85/my-comment\n    as: string,\n    options: Record<string, any>,\n    // At the moment there are no additional arguments (meaning the rest parameter is empty).\n    // This is meant to protect from future additions to Next.js API, especially since this is an\n    // internal API.\n    ...args: any[]\n  ): Promise<boolean> {\n    const newTransactionName = stripUrlQueryAndFragment(url);\n    // do not start a transaction if it's from the same page\n    if (startTransaction !== undefined && prevTransactionName !== newTransactionName) {\n      if (activeTransaction) {\n        activeTransaction.finish();\n      }\n      const tags: Record<string, Primitive> = {\n        ...DEFAULT_TAGS,\n        method,\n        ...options,\n      };\n      if (prevTransactionName) {\n        tags.from = prevTransactionName;\n      }\n      prevTransactionName = newTransactionName;\n      activeTransaction = startTransaction({\n        name: prevTransactionName,\n        op: 'navigation',\n        tags,\n      });\n    }\n    return originalChangeStateWrapper.call(this, method, url, as, options, ...args);\n  };\n  return wrapper;\n}\n"]}