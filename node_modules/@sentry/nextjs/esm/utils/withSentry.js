import { __assign, __awaiter, __generator, __read, __spread, __values } from "tslib";
import { captureException, flush, getCurrentHub, Handlers, startTransaction } from '@sentry/node';
import { extractTraceparentData, hasTracingEnabled } from '@sentry/tracing';
import { addExceptionMechanism, isString, logger, objectify, stripUrlQueryAndFragment } from '@sentry/utils';
import * as domain from 'domain';
var parseRequest = Handlers.parseRequest;
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export var withSentry = function (origHandler) {
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    return function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
        var local, boundHandler;
        return __generator(this, function (_a) {
            // first order of business: monkeypatch `res.end()` so that it will wait for us to send events to sentry before it
            // fires (if we don't do this, the lambda will close too early and events will be either delayed or lost)
            // eslint-disable-next-line @typescript-eslint/unbound-method
            res.end = wrapEndMethod(res.end);
            local = domain.create();
            local.add(req);
            local.add(res);
            boundHandler = local.bind(function () { return __awaiter(void 0, void 0, void 0, function () {
                var currentScope, traceparentData, url, reqPath, _a, _b, _c, key, value, reqMethod, transaction, handlerResult, e_1, objectifiedErr;
                var e_2, _d;
                var _e;
                return __generator(this, function (_f) {
                    switch (_f.label) {
                        case 0:
                            currentScope = getCurrentHub().getScope();
                            if (currentScope) {
                                currentScope.addEventProcessor(function (event) { return parseRequest(event, req); });
                                if (hasTracingEnabled()) {
                                    traceparentData = void 0;
                                    if (req.headers && isString(req.headers['sentry-trace'])) {
                                        traceparentData = extractTraceparentData(req.headers['sentry-trace']);
                                        logger.log("[Tracing] Continuing trace " + ((_e = traceparentData) === null || _e === void 0 ? void 0 : _e.traceId) + ".");
                                    }
                                    url = "" + req.url;
                                    reqPath = stripUrlQueryAndFragment(url);
                                    // Replace with placeholder
                                    if (req.query) {
                                        try {
                                            // TODO get this from next if possible, to avoid accidentally replacing non-dynamic parts of the path if
                                            // they match dynamic parts
                                            for (_a = __values(Object.entries(req.query)), _b = _a.next(); !_b.done; _b = _a.next()) {
                                                _c = __read(_b.value, 2), key = _c[0], value = _c[1];
                                                reqPath = reqPath.replace("" + value, "[" + key + "]");
                                            }
                                        }
                                        catch (e_2_1) { e_2 = { error: e_2_1 }; }
                                        finally {
                                            try {
                                                if (_b && !_b.done && (_d = _a.return)) _d.call(_a);
                                            }
                                            finally { if (e_2) throw e_2.error; }
                                        }
                                    }
                                    reqMethod = (req.method || 'GET').toUpperCase() + " ";
                                    transaction = startTransaction(__assign({ name: "" + reqMethod + reqPath, op: 'http.server' }, traceparentData), 
                                    // extra context passed to the `tracesSampler`
                                    { request: req });
                                    currentScope.setSpan(transaction);
                                    // save a link to the transaction on the response, so that even if there's an error (landing us outside of
                                    // the domain), we can still finish it (albeit possibly missing some scope data)
                                    res.__sentryTransaction = transaction;
                                }
                            }
                            _f.label = 1;
                        case 1:
                            _f.trys.push([1, 3, , 5]);
                            return [4 /*yield*/, origHandler(req, res)];
                        case 2:
                            handlerResult = _f.sent();
                            if (process.env.NODE_ENV === 'development') {
                                // eslint-disable-next-line no-console
                                console.warn('[sentry] If Next.js logs a warning "API resolved without sending a response", it\'s a false positive, which we\'re working to rectify.');
                            }
                            return [2 /*return*/, handlerResult];
                        case 3:
                            e_1 = _f.sent();
                            objectifiedErr = objectify(e_1);
                            if (currentScope) {
                                currentScope.addEventProcessor(function (event) {
                                    addExceptionMechanism(event, {
                                        type: 'instrument',
                                        handled: true,
                                        data: {
                                            wrapped_handler: origHandler.name,
                                            function: 'withSentry',
                                        },
                                    });
                                    return event;
                                });
                                captureException(objectifiedErr);
                            }
                            // Because we're going to finish and send the transaction before passing the error onto nextjs, it won't yet
                            // have had a chance to set the status to 500, so unless we do it ourselves now, we'll incorrectly report that
                            // the transaction was error-free
                            res.statusCode = 500;
                            res.statusMessage = 'Internal Server Error';
                            // Make sure we have a chance to finish the transaction and flush events to Sentry before the handler errors
                            // out. (Apps which are deployed on Vercel run their API routes in lambdas, and those lambdas will shut down the
                            // moment they detect an error, so it's important to get this done before rethrowing the error. Apps not
                            // deployed serverlessly will run into this cleanup function again in `res.end(), but it'll just no-op.)
                            return [4 /*yield*/, finishSentryProcessing(res)];
                        case 4:
                            // Make sure we have a chance to finish the transaction and flush events to Sentry before the handler errors
                            // out. (Apps which are deployed on Vercel run their API routes in lambdas, and those lambdas will shut down the
                            // moment they detect an error, so it's important to get this done before rethrowing the error. Apps not
                            // deployed serverlessly will run into this cleanup function again in `res.end(), but it'll just no-op.)
                            _f.sent();
                            // We rethrow here so that nextjs can do with the error whatever it would normally do. (Sometimes "whatever it
                            // would normally do" is to allow the error to bubble up to the global handlers - another reason we need to mark
                            // the error as already having been captured.)
                            throw objectifiedErr;
                        case 5: return [2 /*return*/];
                    }
                });
            }); });
            // Since API route handlers are all async, nextjs always awaits the return value (meaning it's fine for us to return
            // a promise here rather than a real result, and it saves us the overhead of an `await` call.)
            return [2 /*return*/, boundHandler()];
        });
    }); };
};
/**
 * Wrap `res.end()` so that it closes the transaction and flushes events before letting the request finish.
 *
 * Note: This wraps a sync method with an async method. While in general that's not a great idea in terms of keeping
 * things in the right order, in this case it's safe, because the native `.end()` actually *is* async, and its run
 * actually *is* awaited, just manually so (which reflects the fact that the core of the request/response code in Node
 * by far predates the introduction of `async`/`await`). When `.end()` is done, it emits the `prefinish` event, and
 * only once that fires does request processing continue. See
 * https://github.com/nodejs/node/commit/7c9b607048f13741173d397795bac37707405ba7.
 *
 * @param origEnd The original `res.end()` method
 * @returns The wrapped version
 */
function wrapEndMethod(origEnd) {
    return function newEnd() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, finishSentryProcessing(this)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, origEnd.call.apply(origEnd, __spread([this], args))];
                }
            });
        });
    };
}
/**
 * Close the open transaction (if any) and flush events to Sentry.
 *
 * @param res The outgoing response for this request, on which the transaction is stored
 */
function finishSentryProcessing(res) {
    return __awaiter(this, void 0, void 0, function () {
        var transaction, transactionFinished, e_3;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    transaction = res.__sentryTransaction;
                    if (!transaction) return [3 /*break*/, 2];
                    transaction.setHttpStatus(res.statusCode);
                    transactionFinished = new Promise(function (resolve) {
                        setImmediate(function () {
                            transaction.finish();
                            resolve();
                        });
                    });
                    return [4 /*yield*/, transactionFinished];
                case 1:
                    _a.sent();
                    _a.label = 2;
                case 2:
                    _a.trys.push([2, 4, , 5]);
                    logger.log('Flushing events...');
                    return [4 /*yield*/, flush(2000)];
                case 3:
                    _a.sent();
                    logger.log('Done flushing events');
                    return [3 /*break*/, 5];
                case 4:
                    e_3 = _a.sent();
                    logger.log('Error while flushing events:\n', e_3);
                    return [3 /*break*/, 5];
                case 5: return [2 /*return*/];
            }
        });
    });
}
//# sourceMappingURL=withSentry.js.map