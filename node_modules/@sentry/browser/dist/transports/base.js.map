{"version":3,"file":"base.js","sourceRoot":"","sources":["../../src/transports/base.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  APIDetails,\n  eventToSentryRequest,\n  getEnvelopeEndpointWithUrlEncodedAuth,\n  getStoreEndpointWithUrlEncodedAuth,\n  initAPIDetails,\n  sessionToSentryRequest,\n} from '@sentry/core';\nimport {\n  ClientReport,\n  Event,\n  Outcome,\n  Response as SentryResponse,\n  SentryRequest,\n  SentryRequestType,\n  Session,\n  Transport,\n  TransportOptions,\n} from '@sentry/types';\nimport {\n  createClientReportEnvelope,\n  dsnToString,\n  eventStatusFromHttpCode,\n  getGlobalObject,\n  isDebugBuild,\n  logger,\n  makePromiseBuffer,\n  parseRetryAfterHeader,\n  PromiseBuffer,\n  serializeEnvelope,\n} from '@sentry/utils';\n\nimport { sendReport } from './utils';\n\nfunction requestTypeToCategory(ty: SentryRequestType): string {\n  const tyStr = ty as string;\n  return tyStr === 'event' ? 'error' : tyStr;\n}\n\nconst global = getGlobalObject<Window>();\n\n/** Base Transport class implementation */\nexport abstract class BaseTransport implements Transport {\n  /**\n   * @deprecated\n   */\n  public url: string;\n\n  /** Helper to get Sentry API endpoints. */\n  protected readonly _api: APIDetails;\n\n  /** A simple buffer holding all requests. */\n  protected readonly _buffer: PromiseBuffer<SentryResponse> = makePromiseBuffer(30);\n\n  /** Locks transport after receiving rate limits in a response */\n  protected readonly _rateLimits: Record<string, Date> = {};\n\n  protected _outcomes: { [key: string]: number } = {};\n\n  public constructor(public options: TransportOptions) {\n    this._api = initAPIDetails(options.dsn, options._metadata, options.tunnel);\n    // eslint-disable-next-line deprecation/deprecation\n    this.url = getStoreEndpointWithUrlEncodedAuth(this._api.dsn);\n\n    if (this.options.sendClientReports && global.document) {\n      global.document.addEventListener('visibilitychange', () => {\n        if (global.document.visibilityState === 'hidden') {\n          this._flushOutcomes();\n        }\n      });\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public sendEvent(event: Event): PromiseLike<SentryResponse> {\n    return this._sendRequest(eventToSentryRequest(event, this._api), event);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public sendSession(session: Session): PromiseLike<SentryResponse> {\n    return this._sendRequest(sessionToSentryRequest(session, this._api), session);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public close(timeout?: number): PromiseLike<boolean> {\n    return this._buffer.drain(timeout);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public recordLostEvent(reason: Outcome, category: SentryRequestType): void {\n    if (!this.options.sendClientReports) {\n      return;\n    }\n    // We want to track each category (event, transaction, session) separately\n    // but still keep the distinction between different type of outcomes.\n    // We could use nested maps, but it's much easier to read and type this way.\n    // A correct type for map-based implementation if we want to go that route\n    // would be `Partial<Record<SentryRequestType, Partial<Record<Outcome, number>>>>`\n    const key = `${requestTypeToCategory(category)}:${reason}`;\n    logger.log(`Adding outcome: ${key}`);\n    this._outcomes[key] = (this._outcomes[key] ?? 0) + 1;\n  }\n\n  /**\n   * Send outcomes as an envelope\n   */\n  protected _flushOutcomes(): void {\n    if (!this.options.sendClientReports) {\n      return;\n    }\n\n    const outcomes = this._outcomes;\n    this._outcomes = {};\n\n    // Nothing to send\n    if (!Object.keys(outcomes).length) {\n      logger.log('No outcomes to flush');\n      return;\n    }\n\n    logger.log(`Flushing outcomes:\\n${JSON.stringify(outcomes, null, 2)}`);\n\n    const url = getEnvelopeEndpointWithUrlEncodedAuth(this._api.dsn, this._api.tunnel);\n\n    const discardedEvents = Object.keys(outcomes).map(key => {\n      const [category, reason] = key.split(':');\n      return {\n        reason,\n        category,\n        quantity: outcomes[key],\n      };\n      // TODO: Improve types on discarded_events to get rid of cast\n    }) as ClientReport['discarded_events'];\n    const envelope = createClientReportEnvelope(discardedEvents, this._api.tunnel && dsnToString(this._api.dsn));\n\n    try {\n      sendReport(url, serializeEnvelope(envelope));\n    } catch (e) {\n      logger.error(e);\n    }\n  }\n\n  /**\n   * Handle Sentry repsonse for promise-based transports.\n   */\n  protected _handleResponse({\n    requestType,\n    response,\n    headers,\n    resolve,\n    reject,\n  }: {\n    requestType: SentryRequestType;\n    response: Response | XMLHttpRequest;\n    headers: Record<string, string | null>;\n    resolve: (value?: SentryResponse | PromiseLike<SentryResponse> | null | undefined) => void;\n    reject: (reason?: unknown) => void;\n  }): void {\n    const status = eventStatusFromHttpCode(response.status);\n    /**\n     * \"The name is case-insensitive.\"\n     * https://developer.mozilla.org/en-US/docs/Web/API/Headers/get\n     */\n    const limited = this._handleRateLimit(headers);\n    if (limited && isDebugBuild()) {\n      logger.warn(`Too many ${requestType} requests, backing off until: ${this._disabledUntil(requestType)}`);\n    }\n\n    if (status === 'success') {\n      resolve({ status });\n      return;\n    }\n\n    reject(response);\n  }\n\n  /**\n   * Gets the time that given category is disabled until for rate limiting\n   */\n  protected _disabledUntil(requestType: SentryRequestType): Date {\n    const category = requestTypeToCategory(requestType);\n    return this._rateLimits[category] || this._rateLimits.all;\n  }\n\n  /**\n   * Checks if a category is rate limited\n   */\n  protected _isRateLimited(requestType: SentryRequestType): boolean {\n    return this._disabledUntil(requestType) > new Date(Date.now());\n  }\n\n  /**\n   * Sets internal _rateLimits from incoming headers. Returns true if headers contains a non-empty rate limiting header.\n   */\n  protected _handleRateLimit(headers: Record<string, string | null>): boolean {\n    const now = Date.now();\n    const rlHeader = headers['x-sentry-rate-limits'];\n    const raHeader = headers['retry-after'];\n\n    if (rlHeader) {\n      // rate limit headers are of the form\n      //     <header>,<header>,..\n      // where each <header> is of the form\n      //     <retry_after>: <categories>: <scope>: <reason_code>\n      // where\n      //     <retry_after> is a delay in ms\n      //     <categories> is the event type(s) (error, transaction, etc) being rate limited and is of the form\n      //         <category>;<category>;...\n      //     <scope> is what's being limited (org, project, or key) - ignored by SDK\n      //     <reason_code> is an arbitrary string like \"org_quota\" - ignored by SDK\n      for (const limit of rlHeader.trim().split(',')) {\n        const parameters = limit.split(':', 2);\n        const headerDelay = parseInt(parameters[0], 10);\n        const delay = (!isNaN(headerDelay) ? headerDelay : 60) * 1000; // 60sec default\n        for (const category of parameters[1].split(';')) {\n          this._rateLimits[category || 'all'] = new Date(now + delay);\n        }\n      }\n      return true;\n    } else if (raHeader) {\n      this._rateLimits.all = new Date(now + parseRetryAfterHeader(raHeader, now));\n      return true;\n    }\n    return false;\n  }\n\n  protected abstract _sendRequest(\n    sentryRequest: SentryRequest,\n    originalPayload: Event | Session,\n  ): PromiseLike<SentryResponse>;\n}\n"]}